I finally solved the prime modulo question.  When we use modulus, it forms a set of integers the size of the modulo P: {0, 1, 2, 3, 4, ... P-1}.  A member M of this set is said to have a modular multiplicative inverse X (which is also a member of the set) such that:  (M*X - 1) mod P = 0.  That is all well and fine, but if a member of the set does not have a modular multiplicative inverse, then I discovered that it has a certain property.  For any set member M that does not have a modular multiplicative inverse and any integer N that is a multiple of M, N mod P will always result in a multiple of M.  This makes the modulo function very biased if N is a multiple of M.   I also noticed that all the members of the set size P that do not have modular multiplicative inverses are factors or multiples of factors of P.  Thus, the more factors a modulo P has, the more members of its set do not have modular multiplicative inverses. and the more members that do not have modular multiplicative inverses, the more biased the modulo P is.  A hashtable's hash function takes in keys and hashes them to an index within the range of the hash table.  It does this in two steps: randomizing the key into a hashcode, and then range reducing the hashcode to the index of a bucket within the hashtable.  Range reduction is typically done using modulo P where P is the size of the hashtable.  If the hash function's randomizer is produces very random hashcodes, then a biased modulo P will not matter.  But if the randomizer is not good and uses an integer constant as part of its method, it will produce hashcodes that are multiples of the hash constant.  If the hash constant has lots of factors, it could share a factor with the biased modulo P and the hash codes produced by the randomizer will be multiples of factors of P, which is bad because factors of P do not have modular multiplicative inverses and thus all multiples of the factors will only range reduce to multiples of the factors.

We do not want our modulo function to express biases of our randomizer.  To do this, we want the modulo P and the hash constant to share as few factors as possible.  If we only have control over modulo P and not the hash constant, we should make P have as few factors as possible.  Prime numbers fit the bill as they only have two factors, 1 and the prime number itself.  A neat thing I learned about prime numbers is that mod P where P is prime produces a Finite Field.  A finite field is a set {0, 1, 2, 3, 4, 5, .. P-1} where all members have a modular multiplicative inverse (and other propertiesâ€¦).  If all members have modular multiplicative inverses, then we avoid the bias property of members that do not have modular multiplicative inverses (N mod P where N is a multiple of M and M does not have a modular multiplicative inverse always results in a multiple of M).  Thus our range reduction is less likely to reproduce biases introduced by our randomizer.
